import os
import logging
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv
import httpx
from pydantic import Field, BaseModel, RootModel # For Pydantic v2+
from typing_extensions import Annotated


from fastmcp import FastMCP
# Load environment variables from .env file if present
load_dotenv()

# --- Logging Configuration ---
DEFAULT_LOG_LEVEL = "INFO"
LOG_LEVEL_ENV = os.getenv("LOG_LEVEL", DEFAULT_LOG_LEVEL).upper()
numeric_log_level = getattr(logging, LOG_LEVEL_ENV, logging.INFO)
if not isinstance(numeric_log_level, int):
    print(f"Warning: Invalid LOG_LEVEL '{LOG_LEVEL_ENV}'. Defaulting to '{DEFAULT_LOG_LEVEL}'.")
    numeric_log_level = logging.INFO

logging.basicConfig(
    level=numeric_log_level,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("piston-mcp-server")

# --- Environment Variables ---
PISTON_API_BASE_URL = os.getenv("PISTON_API_BASE_URL", "https://emkc.org/api/v2/piston").rstrip("/")
PISTON_MCP_PORT = int(os.getenv("PISTON_MCP_PORT", "6800"))

# --- MCP Server Initialization ---
mcp = FastMCP(
    name="piston", #
    instructions=(
        "This server provides tools to execute arbitrary code snippets in various programming languages "
        "using the Piston API. It can also list available languages and their versions for execution. "
        "Use this server when you need to run code provided by the user or generated by yourself to "
        "obtain a result, test a hypothesis, or perform a computation."
    )
    )

# --- Pydantic Models for Piston API ---
class PistonFile(BaseModel):
    name: Optional[str] = None
    content: str
    encoding: Optional[str] = None

class PistonRequest(BaseModel):
    language: str
    version: str
    files: List[PistonFile]
    stdin: Optional[str] = None
    args: Optional[List[str]] = None
    compile_timeout: Optional[int] = None
    run_timeout: Optional[int] = None
    compile_memory_limit: Optional[int] = None
    run_memory_limit: Optional[int] = None

class PistonOutput(BaseModel):
    stdout: str
    stderr: str
    output: str # Combined stdout and stderr
    code: int # Exit code
    signal: Optional[str] = None

class PistonCompileInfo(BaseModel):
    stdout: str
    stderr: str
    output: str
    code: int
    signal: Optional[str] = None

class PistonResponse(BaseModel):
    language: str
    version: str
    run: PistonOutput
    compile: Optional[PistonCompileInfo] = None

class PistonRuntime(BaseModel):
    language: str
    version: str
    aliases: List[str]
    runtime: Optional[str] = None

class PistonRuntimesResponse(RootModel[List[PistonRuntime]]):
    root: List[PistonRuntime]

# --- MCP Tools ---
@mcp.tool()
async def execute_code(
    language: Annotated[str, Field(description="The programming language of the code to be executed (e.g., 'python', 'javascript'). Use 'get_piston_runtimes' to discover available languages.")],
    version: Annotated[str, Field(description="The specific version of the programming language to use for execution (e.g., '3.10.0' for python). Use 'get_piston_runtimes' to find supported versions.")],
    code: Annotated[str, Field(description="The actual source code snippet to execute.")],
    file_name: Annotated[Optional[str], Field(description="Optional name for the file containing the code (e.g., 'main.py', 'script.js'). Defaults to 'main.py'. This is primarily for context if the code expects a filename.")] = "main.py",
    stdin: Annotated[Optional[str], Field(description="Standard input (stdin) to be passed to the executing code. Useful for scripts that read from stdin.")] = None,
    args: Annotated[Optional[List[str]], Field(description="A list of command-line arguments to be passed to the executed code.")] = None
) -> Dict[str, Any]:
    # MODIFIED: Enhanced docstring for clarity on code execution
    """
    Executes a given snippet of source code in a specified programming language and version using the Piston API.
    This tool is essential for running code to get results, test algorithms, or perform dynamic computations.
    The Piston API (public instance at https://emkc.org/api/v2/piston) handles the actual code execution in a sandboxed environment.
    Input: language, version, and the code itself. Optional: stdin, command-line arguments, and a filename.
    Output: A dictionary containing the Piston API's response, which includes:
        - 'language': The language used.
        - 'version': The version of the language used.
        - 'run': An object with 'stdout', 'stderr', 'output' (combined stdout/stderr), 'code' (exit code), and 'signal' (if any).
        - 'compile' (optional): An object with details if a compilation step was involved, similar to 'run'.
    Returns an error structure if the API request fails or an unexpected error occurs during the process.
    """
    api_url = f"{PISTON_API_BASE_URL}/execute"
    logger.info(f"Tool 'execute_code': Attempting code execution for language '{language}' (version '{version}') via {api_url}")

    request_payload = PistonRequest(
        language=language,
        version=version,
        files=[PistonFile(name=file_name, content=code)],
        stdin=stdin,
        args=args
    ).model_dump(exclude_none=True)

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(api_url, json=request_payload, timeout=30.0) # Timeout for potentially long-running code
            logger.info(f"Tool 'execute_code': Received response from Piston API for code execution. Status: {response}")
            if response.status_code == 400: # Piston API often gives detailed error messages for 400
                error_data = response.json()
                message = error_data.get("message", response.text)
                logger.error(f"Tool 'execute_code': Piston API Bad Request for language '{language}': {message}")
                return {"error": "Piston API Bad Request during code execution", "message": message, "details": error_data}

            response.raise_for_status() # For other HTTP errors
            result = response.json()
            logger.info(f"Tool 'execute_code': Received result from Piston API for code execution. Status: {result}")

            logger.info(f"Tool 'execute_code': Successfully executed code. Language: {result.get('language')}, Version: {result.get('version')}, Exit Code: {result.get('run', {}).get('code')}")
            return result

    except httpx.HTTPStatusError as e:
        error_detail = e.response.text
        try:
            error_json = e.response.json()
            if "message" in error_json:
                error_detail = error_json["message"]
        except Exception:
            pass
        logger.error(f"Tool 'execute_code': API request for code execution failed with status {e.response.status_code}: {error_detail} for language '{language}'")
        return {"error": "API request for code execution failed", "status_code": e.response.status_code, "details": error_detail}
    except httpx.RequestError as e:
        logger.error(f"Tool 'execute_code': Could not connect to Piston API at {api_url} for code execution: {e}")
        return {"error": "Network error connecting to Piston API for code execution", "details": str(e)}
    except Exception as e:
        logger.error(f"Tool 'execute_code': Unexpected error during code execution for language '{language}': {e}", exc_info=True)
        return {"error": "An unexpected error occurred during code execution", "details": str(e)}

#@mcp.tool()
# async def get_piston_runtimes() -> Dict[str, Any]:
#     # MODIFIED: Enhanced docstring to link its utility to code execution
#     """
#     Fetches the list of available programming languages and their specific versions supported for code execution by the Piston API.
#     This tool is a helper for the 'execute_code' tool. Use it to discover valid 'language' and 'version' parameters
#     before attempting to execute code.
#     Output: A dictionary containing a list of 'runtimes'. Each runtime object specifies:
#         - 'language': The name of the language.
#         - 'version': The specific version of the language.
#         - 'aliases': A list of alternative names for the language.
#         - 'runtime' (optional): A string indicating a specific runtime environment (e.g., 'node', 'python').
#     Returns an error structure if the API request fails.
#     """
#     api_url = f"{PISTON_API_BASE_URL}/runtimes"
#     logger.info(f"Tool 'get_piston_runtimes': Requesting available runtimes for code execution from {api_url}")

#     try:
#         async with httpx.AsyncClient() as client:
#             response = await client.get(api_url, timeout=10.0)
#             response.raise_for_status()
#             runtimes_data = response.json()
#             logger.info(f"Tool 'get_piston_runtimes': Successfully retrieved {len(runtimes_data)} runtimes available for code execution.")
#             return {"runtimes": runtimes_data}
#     except httpx.HTTPStatusError as e:
#         logger.error(f"Tool 'get_piston_runtimes': API request to fetch runtimes failed with status {e.response.status_code}: {e.response.text}")
#         return {"error": "Failed to fetch runtimes from Piston API", "status_code": e.response.status_code, "details": e.response.text}
#     except httpx.RequestError as e:
#         logger.error(f"Tool 'get_piston_runtimes': Could not connect to Piston API at {api_url} to fetch runtimes: {e}")
#         return {"error": "Network error connecting to Piston API for runtimes", "details": str(e)}
#     except Exception as e:
#         logger.error(f"Tool 'get_piston_runtimes': An unexpected error occurred while fetching runtimes: {e}", exc_info=True)
#         return {"error": "An unexpected error occurred while fetching runtimes for code execution", "details": str(e)}

@mcp.tool()
async def get_piston_language_version(language: str) -> Dict[str, Any]:
    """
#     Fetches the list of specific versions supported for code execution by the Piston API.
#     This tool is a helper for the 'execute_code' tool. Use it to discover valid 'language' and 'version' parameters
#     before attempting to execute code.
#     Output: A dictionary containing a list of 'runtimes'. Each runtime object specifies:
#         - 'language': The name of the language.
#         - 'version': The specific version of the language.
#         - 'aliases': A list of alternative names for the language.
#     Returns an error structure if the API request fails.
#     """
    requested_language_lower = language.lower()
    logger.info(f"Piston tool: Effective PISTON_API_BASE_URL = '{PISTON_API_BASE_URL}'")
    runtimes_url = f"{PISTON_API_BASE_URL.rstrip('/')}/runtimes"
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(runtimes_url, timeout=15.0)
            if response.status_code != 200:
                logger.warning(f"Piston Resource: Received status code {response.status_code} from Piston API at {runtimes_url}. Response text: {response.text[:500]}...") # Log first 500 chars of response
            response.raise_for_status()
            all_runtimes_data = response.json()
    

            if not isinstance(all_runtimes_data, list):
                logger.error(f"Piston API ({runtimes_url}) did not return a list. Response: {all_runtimes_data}")
                return f"Error: Piston runtimes API did not return the expected list format while searching for '{language}'."

            found_language_details = None
            for lang_data in all_runtimes_data:
                if not isinstance(lang_data, dict):
                    logger.warning(f"Skipping invalid runtime entry in Piston response: {lang_data}")
                    continue

                piston_lang_name = lang_data.get("language", "").lower()
                piston_aliases = [str(alias).lower() for alias in lang_data.get("aliases", []) if isinstance(alias, (str, int, float))]

                if piston_lang_name == requested_language_lower or requested_language_lower in piston_aliases:
                    found_language_details = lang_data
                    break
            
            if found_language_details:
                actual_lang_name = found_language_details.get("language")
                lang_version = found_language_details.get("version")
                aliases = found_language_details.get("aliases", [])
                aliases_display = ", ".join(aliases) if aliases else "none"
                result_string = f"Language: {actual_lang_name}, Version: {lang_version}, Aliases: [{aliases_display}]"
                logger.info(f"Successfully found runtime for '{language}': {result_string}")
                return {
                    "language": actual_lang_name,
                    "version": lang_version,
                    "aliases": aliases,
                }
            else:
                logger.info(f"Language '{language}' not found in Piston runtimes after checking {len(all_runtimes_data)} entries.")
                return {"Info": f"Runtime information for language '{language}' not found in Piston."}

    except httpx.HTTPStatusError as e:
        # This block will be hit if response.raise_for_status() triggers for 4xx/5xx
        logger.error(f"Piston Resource: HTTP error {e.response.status_code} when calling {e.request.url}. Response: {e.response.text[:500]}", exc_info=True) # Log more details
        return {"Error": f"Could not fetch Piston runtimes for '{language}'. API Error (status {e.response.status_code})."} 
    except httpx.RequestError as e:
        logger.error(f"Piston Resource: Request error connecting to Piston API for '{language}' at {e.request.url}: {e}", exc_info=True)
        return {"Error": f"Could not connect to Piston API to get runtime for '{language}'."}
    except Exception as e:
        logger.error(f"Piston Resource: Unexpected error processing Piston runtimes for '{language}': {e}", exc_info=True)
        return {"Error": f"An unexpected error occurred while fetching runtime for '{language}'."}


@mcp.resource(uri="language://{language}/version")
async def get_language_version_resource(language: str) -> Dict[str, Any]:
    """Retrieves information about a version availables for specific language."""
    requested_language_lower = language.lower()

    logger.info(f"Piston Resource: Effective PISTON_API_BASE_URL = '{PISTON_API_BASE_URL}'")
    
    runtimes_url = f"{PISTON_API_BASE_URL.rstrip('/')}/runtimes"
    
    logger.critical(f"Piston Resource: Attempting to call Piston API at derived URL: '{runtimes_url}' for language '{language}'")
    
    logger.info(f"Requesting Piston runtime version for language '{language}' using resource URI language://{language}/version")

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(runtimes_url, timeout=15.0)
            if response.status_code != 200:
                logger.warning(f"Piston Resource: Received status code {response.status_code} from Piston API at {runtimes_url}. Response text: {response.text[:500]}...") # Log first 500 chars of response
            response.raise_for_status()
            all_runtimes_data = response.json()
    

            if not isinstance(all_runtimes_data, list):
                logger.error(f"Piston API ({runtimes_url}) did not return a list. Response: {all_runtimes_data}")
                return f"Error: Piston runtimes API did not return the expected list format while searching for '{language}'."

            found_language_details = None
            for lang_data in all_runtimes_data:
                if not isinstance(lang_data, dict):
                    logger.warning(f"Skipping invalid runtime entry in Piston response: {lang_data}")
                    continue

                piston_lang_name = lang_data.get("language", "").lower()
                piston_aliases = [str(alias).lower() for alias in lang_data.get("aliases", []) if isinstance(alias, (str, int, float))]

                if piston_lang_name == requested_language_lower or requested_language_lower in piston_aliases:
                    found_language_details = lang_data
                    break
            
            if found_language_details:
                actual_lang_name = found_language_details.get("language")
                lang_version = found_language_details.get("version")
                aliases = found_language_details.get("aliases", [])
                aliases_display = ", ".join(aliases) if aliases else "none"
                result_string = f"Language: {actual_lang_name}, Version: {lang_version}, Aliases: [{aliases_display}]"
                logger.info(f"Successfully found runtime for '{language}': {result_string}")
                return {
                    "language": actual_lang_name,
                    "version": lang_version,
                    "aliases": aliases,
                }
            else:
                logger.info(f"Language '{language}' not found in Piston runtimes after checking {len(all_runtimes_data)} entries.")
                return {"Info": f"Runtime information for language '{language}' not found in Piston."}
    except httpx.HTTPStatusError as e:
        # This block will be hit if response.raise_for_status() triggers for 4xx/5xx
        logger.error(f"Piston Resource: HTTP error {e.response.status_code} when calling {e.request.url}. Response: {e.response.text[:500]}", exc_info=True) # Log more details
        return {"Error": f"Could not fetch Piston runtimes for '{language}'. API Error (status {e.response.status_code})."} 
    except httpx.RequestError as e:
        logger.error(f"Piston Resource: Request error connecting to Piston API for '{language}' at {e.request.url}: {e}", exc_info=True)
        return {"Error": f"Could not connect to Piston API to get runtime for '{language}'."}
    except Exception as e:
        logger.error(f"Piston Resource: Unexpected error processing Piston runtimes for '{language}': {e}", exc_info=True)
        return {"Error": f"An unexpected error occurred while fetching runtime for '{language}'."}


def main():
    logger.info(f"Starting Piston Code Execution MCP Server on port {PISTON_MCP_PORT} with log level {LOG_LEVEL_ENV}")
    logger.info(f"Piston API Base URL for code execution configured to: {PISTON_API_BASE_URL}")
    mcp.run(transport="streamable-http",
        host="0.0.0.0",
        port=PISTON_MCP_PORT,
        log_level=LOG_LEVEL_ENV.lower()
    )

if __name__ == "__main__":
    main()