import os
import logging
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv
import httpx
from pydantic import Field, BaseModel, RootModel # For Pydantic v2+
from typing_extensions import Annotated


from fastmcp import FastMCP
# Load environment variables from .env file if present
load_dotenv()

# --- Logging Configuration ---
DEFAULT_LOG_LEVEL = "INFO"
LOG_LEVEL_ENV = os.getenv("LOG_LEVEL", DEFAULT_LOG_LEVEL).upper()
numeric_log_level = getattr(logging, LOG_LEVEL_ENV, logging.INFO)
if not isinstance(numeric_log_level, int):
    print(f"Warning: Invalid LOG_LEVEL '{LOG_LEVEL_ENV}'. Defaulting to '{DEFAULT_LOG_LEVEL}'.")
    numeric_log_level = logging.INFO

logging.basicConfig(
    level=numeric_log_level,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("piston-mcp-server")

# --- Environment Variables ---
PISTON_API_BASE_URL = os.getenv("PISTON_API_BASE_URL", "https://emkc.org/api/v2/piston").rstrip("/")
PISTON_MCP_PORT = int(os.getenv("PISTON_MCP_PORT", "6800"))

# --- MCP Server Initialization ---
mcp = FastMCP(
    name="piston",
    instructions=(
        "This server provides tools to execute arbitrary code snippets in various programming languages "
        "using the Piston API. It automatically selects the highest available version when no specific "
        "version is provided, making it easy for LLMs to execute code without version details. "
        "Available tools: execute_code (with auto-version selection), get_piston_runtimes (list all languages), "
        "get_available_language_versions (get versions for specific language), and get_piston_language_version "
        "(get single version info). Use this server when you need to run code provided by the user or "
        "generated by yourself to obtain a result, test a hypothesis, or perform a computation."
    )
)

# --- Pydantic Models for Piston API ---
class PistonFile(BaseModel):
    name: Optional[str] = None
    content: str
    encoding: Optional[str] = None

class PistonRequest(BaseModel):
    language: str
    version: str
    files: List[PistonFile]
    stdin: Optional[str] = None
    args: Optional[List[str]] = None
    compile_timeout: Optional[int] = None
    run_timeout: Optional[int] = None
    compile_memory_limit: Optional[int] = None
    run_memory_limit: Optional[int] = None

class PistonOutput(BaseModel):
    stdout: str
    stderr: str
    output: str # Combined stdout and stderr
    code: int # Exit code
    signal: Optional[str] = None

class PistonCompileInfo(BaseModel):
    stdout: str
    stderr: str
    output: str
    code: int
    signal: Optional[str] = None

class PistonResponse(BaseModel):
    language: str
    version: str
    run: PistonOutput
    compile: Optional[PistonCompileInfo] = None

class PistonRuntime(BaseModel):
    language: str
    version: str
    aliases: List[str]
    runtime: Optional[str] = None

class PistonRuntimesResponse(RootModel[List[PistonRuntime]]):
    root: List[PistonRuntime]

# --- MCP Tools ---

async def _get_all_language_versions(language: str) -> Dict[str, Any]:
    """Helper function to get all available versions for a language."""
    requested_language_lower = language.lower()
    runtimes_url = f"{PISTON_API_BASE_URL}/runtimes"
    
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(runtimes_url, timeout=15.0)
            response.raise_for_status()
            all_runtimes_data = response.json()
            
            if not isinstance(all_runtimes_data, list):
                return {"error": "Piston API did not return expected list format"}
            
            matching_versions = []
            for lang_data in all_runtimes_data:
                if not isinstance(lang_data, dict):
                    continue
                    
                piston_lang_name = lang_data.get("language", "").lower()
                piston_aliases = [str(alias).lower() for alias in lang_data.get("aliases", []) 
                                if isinstance(alias, (str, int, float))]
                
                if piston_lang_name == requested_language_lower or requested_language_lower in piston_aliases:
                    matching_versions.append({
                        "language": lang_data.get("language"),
                        "version": lang_data.get("version"),
                        "aliases": lang_data.get("aliases", [])
                    })
            
            if matching_versions:
                return {"versions": matching_versions}
            else:
                return {"error": f"No versions found for language '{language}'"}
                
    except Exception as e:
        logger.error(f"Error fetching language versions: {e}")
        return {"error": f"Failed to fetch versions: {str(e)}"}

def _parse_version(version_string: str) -> tuple:
    """Parse a version string into comparable components."""
    try:
        # Handle common version formats: "3.9.2", "14.21.3", "1.70.0", etc.
        parts = []
        for part in version_string.split('.'):
            # Extract numeric part from strings like "3.9.2" or "14.21.3"
            import re
            numeric_match = re.match(r'(\d+)', part)
            if numeric_match:
                parts.append(int(numeric_match.group(1)))
            else:
                parts.append(0)
        return tuple(parts)
    except:
        # Fallback: if parsing fails, return a tuple that will sort this version last
        return (0,)

def _get_highest_version(versions: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Select the highest version from a list of version dictionaries."""
    if not versions:
        return None
    
    # Sort versions by parsed version number (highest first)
    sorted_versions = sorted(
        versions,
        key=lambda v: _parse_version(v.get("version", "0.0.0")),
        reverse=True
    )
    
    return sorted_versions[0]

@mcp.tool()
async def execute_code(
    language: Annotated[str, Field(description="The programming language of the code to be executed (e.g., 'python', 'javascript'). The system will automatically use the highest available version.")],
    code: Annotated[str, Field(description="The actual source code snippet to execute.")],
    version: Annotated[Optional[str], Field(description="Optional specific version of the language to use. If not provided, the highest available version will be used automatically.")] = None,
    file_name: Annotated[Optional[str], Field(description="Optional name for the file containing the code (e.g., 'main.py', 'script.js'). Defaults to 'main.py'.")] = "main.py",
    stdin: Annotated[Optional[str], Field(description="Standard input (stdin) to be passed to the executing code.")] = None,
    args: Annotated[Optional[List[str]], Field(description="A list of command-line arguments to be passed to the executed code.")] = None
) -> Dict[str, Any]:
    """
    Executes a given snippet of source code in a specified programming language using the Piston API.
    If no version is specified, automatically uses the highest available version for the language.
    
    Input: language and the code itself. Optional: specific version, stdin, command-line arguments, and a filename.
    Output: A dictionary containing the Piston API's response, which includes:
        - 'language': The language used.
        - 'version': The version of the language used.
        - 'run': An object with 'stdout', 'stderr', 'output' (combined stdout/stderr), 'code' (exit code), and 'signal' (if any).
        - 'compile' (optional): An object with details if a compilation step was involved, similar to 'run'.
    Returns an error structure if the API request fails, a version cannot be found, or an unexpected error occurs.
    """
    logger.info(f"Tool 'execute_code': Attempting code execution for language '{language}'")
    
    # Determine which version to use
    if version:
        # User specified a version, validate it exists
        logger.info(f"Tool 'execute_code': User specified version '{version}' for language '{language}'")
        version_info = await get_piston_language_version(language)
        
        if "Error" in version_info or "Info" in version_info:
            logger.error(f"Tool 'execute_code': Could not find language '{language}'. Response: {version_info}")
            return {"error": f"Language '{language}' not supported.", "details": version_info.get("Error") or version_info.get("Info")}
        
        # Check if the specified version matches any available version
        all_versions_info = await _get_all_language_versions(language)
        if "error" in all_versions_info:
            return {"error": f"Could not get versions for language '{language}'", "details": all_versions_info["error"]}
        
        available_versions = [v["version"] for v in all_versions_info["versions"]]
        if version not in available_versions:
            return {
                "error": f"Version '{version}' not available for language '{language}'",
                "available_versions": available_versions,
                "suggestion": f"Use the highest available version or specify one of: {', '.join(available_versions)}"
            }
        
        selected_version = version
        logger.info(f"Tool 'execute_code': Using user-specified version '{selected_version}' for language '{language}'")
    else:
        # Auto-select the highest version
        logger.info(f"Tool 'execute_code': No version specified, finding highest available version for language '{language}'")
        all_versions_info = await _get_all_language_versions(language)
        
        if "error" in all_versions_info:
            return {"error": f"Could not get versions for language '{language}'", "details": all_versions_info["error"]}
        
        if not all_versions_info["versions"]:
            return {"error": f"No versions available for language '{language}'"}
        
        highest_version_info = _get_highest_version(all_versions_info["versions"])
        selected_version = highest_version_info["version"]
        
        logger.info(f"Tool 'execute_code': Auto-selected highest version '{selected_version}' for language '{language}' from {len(all_versions_info['versions'])} available versions")
    
    # Execute the code with the selected version
    api_url = f"{PISTON_API_BASE_URL}/execute"
    request_payload = PistonRequest(
        language=language,
        version=selected_version,
        files=[PistonFile(name=file_name, content=code)],
        stdin=stdin,
        args=args
    ).model_dump(exclude_none=True)

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(api_url, json=request_payload, timeout=30.0)
            logger.debug(f"Tool 'execute_code': Raw Piston API response status: {response.status_code}, content: {response.text[:500]}")
            
            if response.status_code == 400:
                error_data = response.json()
                message = error_data.get("message", response.text)
                logger.error(f"Tool 'execute_code': Piston API Bad Request for language '{language}' version '{selected_version}': {message}")
                return {"error": "Piston API Bad Request during code execution", "message": message, "details": error_data}

            response.raise_for_status()
            result = response.json()
            
            # Add version selection info to the result
            result["version_selection"] = {
                "requested_version": version,
                "selected_version": selected_version,
                "auto_selected": version is None
            }
            
            logger.info(f"Tool 'execute_code': Successfully executed code. Language: {result.get('language')}, Version: {result.get('version')}, Exit Code: {result.get('run', {}).get('code')}")
            return result

    except httpx.HTTPStatusError as e:
        error_detail = e.response.text
        try:
            error_json = e.response.json()
            if "message" in error_json:
                error_detail = error_json["message"]
        except Exception:
            pass
        logger.error(f"Tool 'execute_code': API request for code execution failed with status {e.response.status_code}: {error_detail} for language '{language}' version '{selected_version}'")
        return {"error": "API request for code execution failed", "status_code": e.response.status_code, "details": error_detail}
    except httpx.RequestError as e:
        logger.error(f"Tool 'execute_code': Could not connect to Piston API at {api_url} for code execution: {e}")
        return {"error": "Network error connecting to Piston API for code execution", "details": str(e)}
    except Exception as e:
        logger.error(f"Tool 'execute_code': Unexpected error during code execution for language '{language}' version '{selected_version}': {e}", exc_info=True)
        return {"error": "An unexpected error occurred during code execution", "details": str(e)}


@mcp.tool()
async def get_available_language_versions(
    language: Annotated[str, Field(description="The programming language to get available versions for (e.g., 'python', 'javascript', 'java')")]
) -> Dict[str, Any]:
    """
    Get all available versions for a specific programming language.
    This is useful for seeing what versions are available before executing code.
    """
    logger.info(f"Tool 'get_available_language_versions': Getting all versions for language '{language}'")
    
    all_versions_info = await _get_all_language_versions(language)
    
    if "error" in all_versions_info:
        return {"error": f"Could not get versions for language '{language}'", "details": all_versions_info["error"]}
    
    versions = all_versions_info["versions"]
    if not versions:
        return {"language": language, "versions": [], "message": f"No versions found for language '{language}'"}
    
    # Sort versions (highest first)
    sorted_versions = sorted(
        versions,
        key=lambda v: _parse_version(v.get("version", "0.0.0")),
        reverse=True
    )
    
    highest_version = sorted_versions[0]["version"]
    
    return {
        "language": language,
        "total_versions": len(sorted_versions),
        "highest_version": highest_version,
        "versions": [v["version"] for v in sorted_versions],
        "version_details": sorted_versions
    }

@mcp.tool()
async def get_piston_runtimes() -> Dict[str, Any]:
    """
    Fetches the list of all available programming languages and their versions supported for code execution.
    Use this tool to discover what languages and versions are available before executing code.
    """
    api_url = f"{PISTON_API_BASE_URL}/runtimes"
    logger.info(f"Tool 'get_piston_runtimes': Requesting available runtimes from {api_url}")

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(api_url, timeout=10.0)
            response.raise_for_status()
            runtimes_data = response.json()
            
            # Group by language and include version counts
            language_summary = {}
            for runtime in runtimes_data:
                lang = runtime.get("language", "unknown")
                if lang not in language_summary:
                    language_summary[lang] = {
                        "language": lang,
                        "versions": [],
                        "aliases": runtime.get("aliases", [])
                    }
                language_summary[lang]["versions"].append(runtime.get("version", "unknown"))
            
            # Sort versions for each language
            for lang_info in language_summary.values():
                lang_info["versions"] = sorted(
                    lang_info["versions"],
                    key=lambda v: _parse_version(v),
                    reverse=True
                )
                lang_info["version_count"] = len(lang_info["versions"])
                lang_info["highest_version"] = lang_info["versions"][0] if lang_info["versions"] else "unknown"
            
            logger.info(f"Tool 'get_piston_runtimes': Successfully retrieved {len(runtimes_data)} runtimes for {len(language_summary)} languages")
            
            return {
                "total_runtimes": len(runtimes_data),
                "total_languages": len(language_summary),
                "language_summary": list(language_summary.values()),
                "all_runtimes": runtimes_data
            }
            
    except httpx.HTTPStatusError as e:
        logger.error(f"Tool 'get_piston_runtimes': API request failed with status {e.response.status_code}: {e.response.text}")
        return {"error": "Failed to fetch runtimes from Piston API", "status_code": e.response.status_code, "details": e.response.text}
    except httpx.RequestError as e:
        logger.error(f"Tool 'get_piston_runtimes': Could not connect to Piston API at {api_url}: {e}")
        return {"error": "Network error connecting to Piston API for runtimes", "details": str(e)}
    except Exception as e:
        logger.error(f"Tool 'get_piston_runtimes': Unexpected error: {e}", exc_info=True)
        return {"error": "An unexpected error occurred while fetching runtimes", "details": str(e)}


#@mcp.tool()
# async def get_piston_runtimes() -> Dict[str, Any]:
#     # MODIFIED: Enhanced docstring to link its utility to code execution
#     """
#     Fetches the list of available programming languages and their specific versions supported for code execution by the Piston API.
#     This tool is a helper for the 'execute_code' tool. Use it to discover valid 'language' and 'version' parameters
#     before attempting to execute code.
#     Output: A dictionary containing a list of 'runtimes'. Each runtime object specifies:
#         - 'language': The name of the language.
#         - 'version': The specific version of the language.
#         - 'aliases': A list of alternative names for the language.
#         - 'runtime' (optional): A string indicating a specific runtime environment (e.g., 'node', 'python').
#     Returns an error structure if the API request fails.
#     """
#     api_url = f"{PISTON_API_BASE_URL}/runtimes"
#     logger.info(f"Tool 'get_piston_runtimes': Requesting available runtimes for code execution from {api_url}")

#     try:
#         async with httpx.AsyncClient() as client:
#             response = await client.get(api_url, timeout=10.0)
#             response.raise_for_status()
#             runtimes_data = response.json()
#             logger.info(f"Tool 'get_piston_runtimes': Successfully retrieved {len(runtimes_data)} runtimes available for code execution.")
#             return {"runtimes": runtimes_data}
#     except httpx.HTTPStatusError as e:
#         logger.error(f"Tool 'get_piston_runtimes': API request to fetch runtimes failed with status {e.response.status_code}: {e.response.text}")
#         return {"error": "Failed to fetch runtimes from Piston API", "status_code": e.response.status_code, "details": e.response.text}
#     except httpx.RequestError as e:
#         logger.error(f"Tool 'get_piston_runtimes': Could not connect to Piston API at {api_url} to fetch runtimes: {e}")
#         return {"error": "Network error connecting to Piston API for runtimes", "details": str(e)}
#     except Exception as e:
#         logger.error(f"Tool 'get_piston_runtimes': An unexpected error occurred while fetching runtimes: {e}", exc_info=True)
#         return {"error": "An unexpected error occurred while fetching runtimes for code execution", "details": str(e)}

@mcp.tool()
async def get_piston_language_version(language: str) -> Dict[str, Any]:
    """
#     Fetches the list of specific versions supported for code execution by the Piston API.
#     This tool is a helper for the 'execute_code' tool. Use it to discover valid 'language' and 'version' parameters
#     before attempting to execute code.
#     Output: A dictionary containing a list of 'runtimes'. Each runtime object specifies:
#         - 'language': The name of the language.
#         - 'version': The specific version of the language.
#         - 'aliases': A list of alternative names for the language.
#     Returns an error structure if the API request fails.
#     """
    requested_language_lower = language.lower()
    logger.info(f"Piston tool: Effective PISTON_API_BASE_URL = '{PISTON_API_BASE_URL}'")
    runtimes_url = f"{PISTON_API_BASE_URL.rstrip('/')}/runtimes"
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(runtimes_url, timeout=15.0)
            if response.status_code != 200:
                logger.warning(f"Piston Resource: Received status code {response.status_code} from Piston API at {runtimes_url}. Response text: {response.text[:500]}...") # Log first 500 chars of response
            response.raise_for_status()
            all_runtimes_data = response.json()
    

            if not isinstance(all_runtimes_data, list):
                logger.error(f"Piston API ({runtimes_url}) did not return a list. Response: {all_runtimes_data}")
                return f"Error: Piston runtimes API did not return the expected list format while searching for '{language}'."

            found_language_details = None
            for lang_data in all_runtimes_data:
                if not isinstance(lang_data, dict):
                    logger.warning(f"Skipping invalid runtime entry in Piston response: {lang_data}")
                    continue

                piston_lang_name = lang_data.get("language", "").lower()
                piston_aliases = [str(alias).lower() for alias in lang_data.get("aliases", []) if isinstance(alias, (str, int, float))]

                if piston_lang_name == requested_language_lower or requested_language_lower in piston_aliases:
                    found_language_details = lang_data
                    break
            
            if found_language_details:
                actual_lang_name = found_language_details.get("language")
                lang_version = found_language_details.get("version")
                aliases = found_language_details.get("aliases", [])
                aliases_display = ", ".join(aliases) if aliases else "none"
                result_string = f"Language: {actual_lang_name}, Version: {lang_version}, Aliases: [{aliases_display}]"
                logger.info(f"Successfully found runtime for '{language}': {result_string}")
                return {
                    "language": actual_lang_name,
                    "version": lang_version,
                    "aliases": aliases,
                }
            else:
                logger.info(f"Language '{language}' not found in Piston runtimes after checking {len(all_runtimes_data)} entries.")
                return {"Info": f"Runtime information for language '{language}' not found in Piston."}

    except httpx.HTTPStatusError as e:
        # This block will be hit if response.raise_for_status() triggers for 4xx/5xx
        logger.error(f"Piston Resource: HTTP error {e.response.status_code} when calling {e.request.url}. Response: {e.response.text[:500]}", exc_info=True) # Log more details
        return {"Error": f"Could not fetch Piston runtimes for '{language}'. API Error (status {e.response.status_code})."} 
    except httpx.RequestError as e:
        logger.error(f"Piston Resource: Request error connecting to Piston API for '{language}' at {e.request.url}: {e}", exc_info=True)
        return {"Error": f"Could not connect to Piston API to get runtime for '{language}'."}
    except Exception as e:
        logger.error(f"Piston Resource: Unexpected error processing Piston runtimes for '{language}': {e}", exc_info=True)
        return {"Error": f"An unexpected error occurred while fetching runtime for '{language}'."}


@mcp.resource(uri="language://{language}/version")
async def get_language_version_resource(language: str) -> Dict[str, Any]:
    """Retrieves information about a version availables for specific language."""
    requested_language_lower = language.lower()

    logger.info(f"Piston Resource: Effective PISTON_API_BASE_URL = '{PISTON_API_BASE_URL}'")
    
    runtimes_url = f"{PISTON_API_BASE_URL.rstrip('/')}/runtimes"
    
    logger.critical(f"Piston Resource: Attempting to call Piston API at derived URL: '{runtimes_url}' for language '{language}'")
    
    logger.info(f"Requesting Piston runtime version for language '{language}' using resource URI language://{language}/version")

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(runtimes_url, timeout=15.0)
            if response.status_code != 200:
                logger.warning(f"Piston Resource: Received status code {response.status_code} from Piston API at {runtimes_url}. Response text: {response.text[:500]}...") # Log first 500 chars of response
            response.raise_for_status()
            all_runtimes_data = response.json()
    

            if not isinstance(all_runtimes_data, list):
                logger.error(f"Piston API ({runtimes_url}) did not return a list. Response: {all_runtimes_data}")
                return f"Error: Piston runtimes API did not return the expected list format while searching for '{language}'."

            found_language_details = None
            for lang_data in all_runtimes_data:
                if not isinstance(lang_data, dict):
                    logger.warning(f"Skipping invalid runtime entry in Piston response: {lang_data}")
                    continue

                piston_lang_name = lang_data.get("language", "").lower()
                piston_aliases = [str(alias).lower() for alias in lang_data.get("aliases", []) if isinstance(alias, (str, int, float))]

                if piston_lang_name == requested_language_lower or requested_language_lower in piston_aliases:
                    found_language_details = lang_data
                    break
            
            if found_language_details:
                actual_lang_name = found_language_details.get("language")
                lang_version = found_language_details.get("version")
                aliases = found_language_details.get("aliases", [])
                aliases_display = ", ".join(aliases) if aliases else "none"
                result_string = f"Language: {actual_lang_name}, Version: {lang_version}, Aliases: [{aliases_display}]"
                logger.info(f"Successfully found runtime for '{language}': {result_string}")
                return {
                    "language": actual_lang_name,
                    "version": lang_version,
                    "aliases": aliases,
                }
            else:
                logger.info(f"Language '{language}' not found in Piston runtimes after checking {len(all_runtimes_data)} entries.")
                return {"Info": f"Runtime information for language '{language}' not found in Piston."}
    except httpx.HTTPStatusError as e:
        # This block will be hit if response.raise_for_status() triggers for 4xx/5xx
        logger.error(f"Piston Resource: HTTP error {e.response.status_code} when calling {e.request.url}. Response: {e.response.text[:500]}", exc_info=True) # Log more details
        return {"Error": f"Could not fetch Piston runtimes for '{language}'. API Error (status {e.response.status_code})."} 
    except httpx.RequestError as e:
        logger.error(f"Piston Resource: Request error connecting to Piston API for '{language}' at {e.request.url}: {e}", exc_info=True)
        return {"Error": f"Could not connect to Piston API to get runtime for '{language}'."}
    except Exception as e:
        logger.error(f"Piston Resource: Unexpected error processing Piston runtimes for '{language}': {e}", exc_info=True)
        return {"Error": f"An unexpected error occurred while fetching runtime for '{language}'."}


def main():
    logger.info(f"Starting Piston Code Execution MCP Server on port {PISTON_MCP_PORT} with log level {LOG_LEVEL_ENV}")
    logger.info(f"Piston API Base URL for code execution configured to: {PISTON_API_BASE_URL}")
    mcp.run(transport="streamable-http",
        host="0.0.0.0",
        port=PISTON_MCP_PORT,
        log_level=LOG_LEVEL_ENV.lower()
    )

if __name__ == "__main__":
    main()