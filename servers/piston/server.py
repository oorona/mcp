import os
import logging
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv
import httpx
from pydantic import Field, BaseModel, RootModel # For Pydantic v2+
from typing_extensions import Annotated


from fastmcp import FastMCP
# Load environment variables from .env file if present
load_dotenv()

# --- Logging Configuration ---
DEFAULT_LOG_LEVEL = "INFO"
LOG_LEVEL_ENV = os.getenv("LOG_LEVEL", DEFAULT_LOG_LEVEL).upper()
numeric_log_level = getattr(logging, LOG_LEVEL_ENV, logging.INFO)
if not isinstance(numeric_log_level, int):
    print(f"Warning: Invalid LOG_LEVEL '{LOG_LEVEL_ENV}'. Defaulting to '{DEFAULT_LOG_LEVEL}'.")
    numeric_log_level = logging.INFO

logging.basicConfig(
    level=numeric_log_level,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("piston-mcp-server")

# --- Environment Variables ---
PISTON_API_BASE_URL = os.getenv("PISTON_API_BASE_URL", "https://emkc.org/api/v2/piston").rstrip("/")
PISTON_MCP_PORT = int(os.getenv("PISTON_MCP_PORT", "6800"))

# --- MCP Server Initialization ---
mcp = FastMCP(
    name="piston", #
    instructions=(
        "This server provides tools to execute arbitrary code snippets in various programming languages "
        "using the Piston API. It can also list available languages and their versions for execution. "
        "Use this server when you need to run code provided by the user or generated by yourself to "
        "obtain a result, test a hypothesis, or perform a computation."
    )
    )

# --- Pydantic Models for Piston API ---
class PistonFile(BaseModel):
    name: Optional[str] = None
    content: str
    encoding: Optional[str] = None

class PistonRequest(BaseModel):
    language: str
    version: str
    files: List[PistonFile]
    stdin: Optional[str] = None
    args: Optional[List[str]] = None
    compile_timeout: Optional[int] = None
    run_timeout: Optional[int] = None
    compile_memory_limit: Optional[int] = None
    run_memory_limit: Optional[int] = None

class PistonOutput(BaseModel):
    stdout: str
    stderr: str
    output: str # Combined stdout and stderr
    code: int # Exit code
    signal: Optional[str] = None

class PistonCompileInfo(BaseModel):
    stdout: str
    stderr: str
    output: str
    code: int
    signal: Optional[str] = None

class PistonResponse(BaseModel):
    language: str
    version: str
    run: PistonOutput
    compile: Optional[PistonCompileInfo] = None

class PistonRuntime(BaseModel):
    language: str
    version: str
    aliases: List[str]
    runtime: Optional[str] = None

class PistonRuntimesResponse(RootModel[List[PistonRuntime]]):
    root: List[PistonRuntime]

# --- MCP Tools ---
@mcp.tool()
async def execute_code(
    language: Annotated[str, Field(description="The programming language of the code to be executed (e.g., 'python', 'javascript'). Use 'get_piston_runtimes' to discover available languages.")],
    version: Annotated[str, Field(description="The specific version of the programming language to use for execution (e.g., '3.10.0' for python). Use 'get_piston_runtimes' to find supported versions.")],
    code: Annotated[str, Field(description="The actual source code snippet to execute.")],
    file_name: Annotated[Optional[str], Field(description="Optional name for the file containing the code (e.g., 'main.py', 'script.js'). Defaults to 'main.py'. This is primarily for context if the code expects a filename.")] = "main.py",
    stdin: Annotated[Optional[str], Field(description="Standard input (stdin) to be passed to the executing code. Useful for scripts that read from stdin.")] = None,
    args: Annotated[Optional[List[str]], Field(description="A list of command-line arguments to be passed to the executed code.")] = None
) -> Dict[str, Any]:
    # MODIFIED: Enhanced docstring for clarity on code execution
    """
    Executes a given snippet of source code in a specified programming language and version using the Piston API.
    This tool is essential for running code to get results, test algorithms, or perform dynamic computations.
    The Piston API (public instance at https://emkc.org/api/v2/piston) handles the actual code execution in a sandboxed environment.
    Input: language, version, and the code itself. Optional: stdin, command-line arguments, and a filename.
    Output: A dictionary containing the Piston API's response, which includes:
        - 'language': The language used.
        - 'version': The version of the language used.
        - 'run': An object with 'stdout', 'stderr', 'output' (combined stdout/stderr), 'code' (exit code), and 'signal' (if any).
        - 'compile' (optional): An object with details if a compilation step was involved, similar to 'run'.
    Returns an error structure if the API request fails or an unexpected error occurs during the process.
    """
    api_url = f"{PISTON_API_BASE_URL}/execute"
    logger.info(f"Tool 'execute_code': Attempting code execution for language '{language}' (version '{version}') via {api_url}")

    request_payload = PistonRequest(
        language=language,
        version=version,
        files=[PistonFile(name=file_name, content=code)],
        stdin=stdin,
        args=args
    ).model_dump(exclude_none=True)

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(api_url, json=request_payload, timeout=30.0) # Timeout for potentially long-running code
            logger.info(f"Tool 'execute_code': Received response from Piston API for code execution. Status: {response}")
            if response.status_code == 400: # Piston API often gives detailed error messages for 400
                error_data = response.json()
                message = error_data.get("message", response.text)
                logger.error(f"Tool 'execute_code': Piston API Bad Request for language '{language}': {message}")
                return {"error": "Piston API Bad Request during code execution", "message": message, "details": error_data}

            response.raise_for_status() # For other HTTP errors
            result = response.json()
            logger.info(f"Tool 'execute_code': Received result from Piston API for code execution. Status: {result}")

            logger.info(f"Tool 'execute_code': Successfully executed code. Language: {result.get('language')}, Version: {result.get('version')}, Exit Code: {result.get('run', {}).get('code')}")
            return result

    except httpx.HTTPStatusError as e:
        error_detail = e.response.text
        try:
            error_json = e.response.json()
            if "message" in error_json:
                error_detail = error_json["message"]
        except Exception:
            pass
        logger.error(f"Tool 'execute_code': API request for code execution failed with status {e.response.status_code}: {error_detail} for language '{language}'")
        return {"error": "API request for code execution failed", "status_code": e.response.status_code, "details": error_detail}
    except httpx.RequestError as e:
        logger.error(f"Tool 'execute_code': Could not connect to Piston API at {api_url} for code execution: {e}")
        return {"error": "Network error connecting to Piston API for code execution", "details": str(e)}
    except Exception as e:
        logger.error(f"Tool 'execute_code': Unexpected error during code execution for language '{language}': {e}", exc_info=True)
        return {"error": "An unexpected error occurred during code execution", "details": str(e)}

@mcp.tool()
async def get_piston_runtimes() -> Dict[str, Any]:
    # MODIFIED: Enhanced docstring to link its utility to code execution
    """
    Fetches the list of available programming languages and their specific versions supported for code execution by the Piston API.
    This tool is a helper for the 'execute_code' tool. Use it to discover valid 'language' and 'version' parameters
    before attempting to execute code.
    Output: A dictionary containing a list of 'runtimes'. Each runtime object specifies:
        - 'language': The name of the language.
        - 'version': The specific version of the language.
        - 'aliases': A list of alternative names for the language.
        - 'runtime' (optional): A string indicating a specific runtime environment (e.g., 'node', 'python').
    Returns an error structure if the API request fails.
    """
    api_url = f"{PISTON_API_BASE_URL}/runtimes"
    logger.info(f"Tool 'get_piston_runtimes': Requesting available runtimes for code execution from {api_url}")

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(api_url, timeout=10.0)
            response.raise_for_status()
            runtimes_data = response.json()
            logger.info(f"Tool 'get_piston_runtimes': Successfully retrieved {len(runtimes_data)} runtimes available for code execution.")
            return {"runtimes": runtimes_data}
    except httpx.HTTPStatusError as e:
        logger.error(f"Tool 'get_piston_runtimes': API request to fetch runtimes failed with status {e.response.status_code}: {e.response.text}")
        return {"error": "Failed to fetch runtimes from Piston API", "status_code": e.response.status_code, "details": e.response.text}
    except httpx.RequestError as e:
        logger.error(f"Tool 'get_piston_runtimes': Could not connect to Piston API at {api_url} to fetch runtimes: {e}")
        return {"error": "Network error connecting to Piston API for runtimes", "details": str(e)}
    except Exception as e:
        logger.error(f"Tool 'get_piston_runtimes': An unexpected error occurred while fetching runtimes: {e}", exc_info=True)
        return {"error": "An unexpected error occurred while fetching runtimes for code execution", "details": str(e)}

# --- Main Execution ---

@mcp.resource(uri="resource://supported_runtimes")
async def piston_supported_runtimes() -> str:
    """
    Fetches the supported languages, their current versions, and aliases from the Piston API.
    This information is provided as context to help select compatible runtimes for code execution.
    The format is: 'Language (version: X.Y.Z, aliases: [alias1, alias2]); ...'
    """
    runtimes_url = f"{PISTON_API_BASE_URL.rstrip('/')}/api/v2/runtimes"
    logger.info(f"Fetching Piston runtimes from: {runtimes_url}")

    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(runtimes_url, timeout=15.0)
            response.raise_for_status()  # Raises an exception for 4xx or 5xx status codes
            runtimes_data = response.json()

            if not isinstance(runtimes_data, list):
                logger.error(f"Piston API at {runtimes_url} did not return a list. Response: {runtimes_data}")
                return "Error: Piston runtimes API did not return the expected list format."

            formatted_runtimes = []
            for lang_data in runtimes_data:
                if not isinstance(lang_data, dict):
                    logger.warning(f"Skipping invalid runtime entry: {lang_data}")
                    continue # Skip if the entry isn't a dictionary

                lang_name = lang_data.get("language")
                lang_version = lang_data.get("version")
                aliases = lang_data.get("aliases", []) # Default to empty list if 'aliases' key is missing
                
                # Ensure aliases is a list and join them, otherwise use a placeholder
                aliases_str = ", ".join(aliases) if isinstance(aliases, list) else "N/A"

                if lang_name and lang_version:
                    formatted_runtimes.append(
                        f"{lang_name} (version: {lang_version}, aliases: [{aliases_str}])"
                    )
            
            if not formatted_runtimes:
                logger.info("No runtimes data found or Piston API returned an empty list.")
                return "Piston Runtimes: No runtimes data currently available from the Piston API."

            result_string = "Available Piston Runtimes: " + "; ".join(formatted_runtimes)
            logger.info(f"Successfully fetched and formatted Piston runtimes: {len(formatted_runtimes)} entries.")
            return result_string

    except httpx.HTTPStatusError as e:
        logger.error(f"HTTP error fetching Piston runtimes: {e.response.status_code} - {e.response.text}", exc_info=True)
        return f"Error: Could not fetch Piston runtimes. API Error (status {e.response.status_code})."
    except httpx.RequestError as e:
        logger.error(f"Request error fetching Piston runtimes: {e}", exc_info=True)
        return f"Error: Could not connect to Piston API at {runtimes_url}."
    except Exception as e:
        logger.error(f"Unexpected error fetching Piston runtimes: {e}", exc_info=True)
        return "Error: An unexpected error occurred while fetching Piston runtimes."

def main():
    logger.info(f"Starting Piston Code Execution MCP Server on port {PISTON_MCP_PORT} with log level {LOG_LEVEL_ENV}")
    logger.info(f"Piston API Base URL for code execution configured to: {PISTON_API_BASE_URL}")
    mcp.run(transport="streamable-http",
        host="0.0.0.0",
        port=PISTON_MCP_PORT,
        log_level=LOG_LEVEL_ENV.lower()
    )

if __name__ == "__main__":
    main()